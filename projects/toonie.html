<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta property="og:image" content="https://hunkim98.github.io/assets/profile/cover_image.png"/><meta name="google-site-verification" content="l9pNikVAOmXekB00LXYnclf9f_nyVIIjDvu4s2DdYtQ"/><title>Toonie: Real-time Collaborative image review editor</title><meta name="description"/><meta name="title" content="Toonie: Real-time Collaborative image review editor"/><meta property="og:image" content="https://hunkim98.github.io/assets/project/toonie/thumbnail.png"/><meta name="next-head-count" content="18"/><link rel="preload" href="/_next/static/css/5d9f08eae59c3c13.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5d9f08eae59c3c13.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8138b1f5e83e865d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8138b1f5e83e865d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-760b458b5ffc5c05.js" defer=""></script><script src="/_next/static/chunks/pages/_app-db05b20490066eb3.js" defer=""></script><script src="/_next/static/chunks/996-446f66ef59abd107.js" defer=""></script><script src="/_next/static/chunks/pages/projects/%5Bslug%5D-57f4a24fa2d224b8.js" defer=""></script><script src="/_next/static/7vnbC7bE2vNc1CHUJ8Hh0/_buildManifest.js" defer=""></script><script src="/_next/static/7vnbC7bE2vNc1CHUJ8Hh0/_ssgManifest.js" defer=""></script></head><body class="bg-[#F1F1F1]"><div id="__next"><div class="min-h-screen text-[#000000]"><main><div class="container mx-auto px-5 max-w-5xl"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/?category=projects">‚Üê More Projects</a></h2><article class="mb-32"><div class="max-w-3xl mx-auto"><div class="mb-6 text-lg"><h1 class="max-w-3xl mx-auto text-5xl md:text-6xl lg:text-6xl font-bold tracking-normal leading-10 md:leading-none mb-12 text-center md:text-left">Toonie: Real-time Collaborative image review editor</h1><div>Category:<!-- --> <span>#<!-- -->opensource</span><span>#<!-- -->collaboration</span><span>#<!-- -->CRDT</span></div></div></div><div class="max-w-3xl mx-auto"><div class="markdown-styles_markdown__h_8de"><p>Collaborative editing is a rising star in software development. Now, people not only want smart editors, but they also want an editor that allows real-time collaboration with other people. Collaborating with other people is a great way to increase productivity and get feedback on your work. The COVID-19 pandemic accelerated the familiarity of collaborative editing, and now, many people are using collaborative editors in their daily lives.</p>
<p>However, implementing a multiplayer aspect into an editor is never an easy task. First, one should have basic knowledge of how to manage multiple actions from multiple agents. What happens if two people try to edit the same part of the document at the same time? What happens if one person deletes a part of the document while the other person is editing the same part? These are the questions that one should be able to answer when they want to implement a collaborative editor. Second, one should have to decide what features shall be communcated between users, and how their actions do not cause overhead. Relaying data between users can be costly and unreliable in some cases, so one should carefully design the data flow between users in a way that it does not harm user experience.</p>
<p>Toonie is a real-time CRDT-based collaborative image review editor that I created to research optimization techniques for implementing CRDT mechanisms into whiteboards. In Toonie, users can review on images uploaded to the service together by sharing a URL to another person. The reason I chose an image review domain specifically is because most collaborative editors out there are for general purposes. Thus, I wanted to create a more narrow focused whiteboard where designers and marketers could review on images together by drawing sketches on the images in an online meeting setting.</p>
<p>
<img alt="Demo" width="100%" src="/assets/project/toonie/edit.png">
<em>Editing Scene</em>
</p>
<p>Toonie wass built on top of the CRDT-based collaborative SDK called <a href="https://github.com/yorkie-team/yorkie">Yorkie</a> which is an opensource document store for building collaborative applications created by Naver Alto TF. While contributing to the opensource project, I created Toonie for demonstrating the capabilities of Yorkie.</p>
<p>When creating a multiplayer whiteboard, one should distinguish between actions that need its commit order to be preserved and actions that do not need its commit order to be preserved. This is because in multiplayer operations, actions that needs its order to be preserved consume much computer resources during communication, which can eventually result in lags. In Yorkie, actions that do not need its order to be preserved were managed as Presence, and those that needed its order to be preserved (= that is in need of management through CRDT algorithms) were managed as Data. In a whiteboard application, the real-time action (interactions that the user commits to the whiteboard while their mouse is down) do not really need to be communcated with its order preserved since their actions are not finished, and thus can be managed as Presence. However, the committed action, which is anfinished action of a user (mouse up after mouse down) should have its order preserved since it is a finished action. Those were managed as Data.</p>
<p>
<img alt="Demo" width="100%" src="/assets/project/toonie/soc_step1.png">
<em>User interaction recorded as presence</em>
</p>
<p>
<img alt="Demo" width="100%" src="/assets/project/toonie/soc_step2.png">
<em>User interaction finishes and presence is reset</em>
</p>
<p>
<img alt="Demo" width="100%" src="/assets/project/toonie/soc_step3.png">
<em>Presence modifications are transferred to data</em>
</p>
<p>Separation of concerns was used for implementing the distinction between Presence and Data, and thus multiple layers (presence canvas and data canvas) was designed for the whiteboard application. User's real-time unfinished interactions (whiteboard modifications that occur while the user's mouse is pressed) were drawn in the Presence canvas. As soon as the user's interaction finishes (user finishes modification by mouseup), then the presence canvas data is reset and the modification data is sent to the Data Canvas. By doing so, I was able to design a software design approach for optimizing collaborative whiteboards.</p>
</div></div><section></section></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"project":{"title":"Toonie: Real-time Collaborative image review editor","date":"2022-08-19","slug":"toonie","author":{"name":"Kim Dong Hun"},"content":"\u003cp\u003eCollaborative editing is a rising star in software development. Now, people not only want smart editors, but they also want an editor that allows real-time collaboration with other people. Collaborating with other people is a great way to increase productivity and get feedback on your work. The COVID-19 pandemic accelerated the familiarity of collaborative editing, and now, many people are using collaborative editors in their daily lives.\u003c/p\u003e\n\u003cp\u003eHowever, implementing a multiplayer aspect into an editor is never an easy task. First, one should have basic knowledge of how to manage multiple actions from multiple agents. What happens if two people try to edit the same part of the document at the same time? What happens if one person deletes a part of the document while the other person is editing the same part? These are the questions that one should be able to answer when they want to implement a collaborative editor. Second, one should have to decide what features shall be communcated between users, and how their actions do not cause overhead. Relaying data between users can be costly and unreliable in some cases, so one should carefully design the data flow between users in a way that it does not harm user experience.\u003c/p\u003e\n\u003cp\u003eToonie is a real-time CRDT-based collaborative image review editor that I created to research optimization techniques for implementing CRDT mechanisms into whiteboards. In Toonie, users can review on images uploaded to the service together by sharing a URL to another person. The reason I chose an image review domain specifically is because most collaborative editors out there are for general purposes. Thus, I wanted to create a more narrow focused whiteboard where designers and marketers could review on images together by drawing sketches on the images in an online meeting setting.\u003c/p\u003e\n\u003cp\u003e\n\u003cimg alt=\"Demo\" width=\"100%\" src=\"/assets/project/toonie/edit.png\"\u003e\n\u003cem\u003eEditing Scene\u003c/em\u003e\n\u003c/p\u003e\n\u003cp\u003eToonie wass built on top of the CRDT-based collaborative SDK called \u003ca href=\"https://github.com/yorkie-team/yorkie\"\u003eYorkie\u003c/a\u003e which is an opensource document store for building collaborative applications created by Naver Alto TF. While contributing to the opensource project, I created Toonie for demonstrating the capabilities of Yorkie.\u003c/p\u003e\n\u003cp\u003eWhen creating a multiplayer whiteboard, one should distinguish between actions that need its commit order to be preserved and actions that do not need its commit order to be preserved. This is because in multiplayer operations, actions that needs its order to be preserved consume much computer resources during communication, which can eventually result in lags. In Yorkie, actions that do not need its order to be preserved were managed as Presence, and those that needed its order to be preserved (= that is in need of management through CRDT algorithms) were managed as Data. In a whiteboard application, the real-time action (interactions that the user commits to the whiteboard while their mouse is down) do not really need to be communcated with its order preserved since their actions are not finished, and thus can be managed as Presence. However, the committed action, which is anfinished action of a user (mouse up after mouse down) should have its order preserved since it is a finished action. Those were managed as Data.\u003c/p\u003e\n\u003cp\u003e\n\u003cimg alt=\"Demo\" width=\"100%\" src=\"/assets/project/toonie/soc_step1.png\"\u003e\n\u003cem\u003eUser interaction recorded as presence\u003c/em\u003e\n\u003c/p\u003e\n\u003cp\u003e\n\u003cimg alt=\"Demo\" width=\"100%\" src=\"/assets/project/toonie/soc_step2.png\"\u003e\n\u003cem\u003eUser interaction finishes and presence is reset\u003c/em\u003e\n\u003c/p\u003e\n\u003cp\u003e\n\u003cimg alt=\"Demo\" width=\"100%\" src=\"/assets/project/toonie/soc_step3.png\"\u003e\n\u003cem\u003ePresence modifications are transferred to data\u003c/em\u003e\n\u003c/p\u003e\n\u003cp\u003eSeparation of concerns was used for implementing the distinction between Presence and Data, and thus multiple layers (presence canvas and data canvas) was designed for the whiteboard application. User's real-time unfinished interactions (whiteboard modifications that occur while the user's mouse is pressed) were drawn in the Presence canvas. As soon as the user's interaction finishes (user finishes modification by mouseup), then the presence canvas data is reset and the modification data is sent to the Data Canvas. By doing so, I was able to design a software design approach for optimizing collaborative whiteboards.\u003c/p\u003e\n","keyword":"collaboration","categories":["opensource","collaboration","CRDT"],"coverImg":"/assets/project/toonie/thumbnail.png"}},"__N_SSG":true},"page":"/projects/[slug]","query":{"slug":"toonie"},"buildId":"7vnbC7bE2vNc1CHUJ8Hh0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>