<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png"/><link rel="manifest" href="/favicon/site.webmanifest"/><link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#000000"/><link rel="shortcut icon" href="/favicon/favicon.ico"/><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-config" content="/favicon/browserconfig.xml"/><meta name="theme-color" content="#000"/><link rel="alternate" type="application/rss+xml" href="/feed.xml"/><meta name="description" content="hunkim98&#x27;s Blog"/><meta property="og:image" content="https://og-image.vercel.app/Next.js%20Blog%20Starter%20Example.png?theme=light&amp;md=1&amp;fontSize=100px&amp;images=https%3A%2F%2Fassets.vercel.com%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="google-site-verification" content="l9pNikVAOmXekB00LXYnclf9f_nyVIIjDvu4s2DdYtQ"/><title>하나의 원본에서 파생된 여러 복사본에 가해지는 operation을 취합하여 통일된 새로운 원본을 만드는 마술(CRDT) - 1. Operation의 디자인 방법 | hunkim98’s Blog</title><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/4343f5467d580d93.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4343f5467d580d93.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8138b1f5e83e865d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8138b1f5e83e865d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-4556c45dd113b893.js" defer=""></script><script src="/_next/static/chunks/main-760b458b5ffc5c05.js" defer=""></script><script src="/_next/static/chunks/pages/_app-db05b20490066eb3.js" defer=""></script><script src="/_next/static/chunks/996-446f66ef59abd107.js" defer=""></script><script src="/_next/static/chunks/358-59e534127f537b93.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-48c2214952b8f8ae.js" defer=""></script><script src="/_next/static/QbQQ_OOkCyxZZcdQD6e3a/_buildManifest.js" defer=""></script><script src="/_next/static/QbQQ_OOkCyxZZcdQD6e3a/_ssgManifest.js" defer=""></script></head><body class="bg-[#F1F1F1]"><div id="__next"><div class="min-h-screen text-[#000000]"><main><div class="container mx-auto px-5 max-w-5xl"><h2 class="text-2xl md:text-4xl font-bold tracking-tight md:tracking-tighter leading-tight mb-20 mt-8"><a class="hover:underline" href="/?category=posts">← More Posts</a></h2><article class="mb-32"><h1 class="max-w-3xl mx-auto text-5xl md:text-6xl lg:text-6xl font-bold tracking-normal leading-10 md:leading-none mb-12 text-center md:text-left">하나의 원본에서 파생된 여러 복사본에 가해지는 operation을 취합하여 통일된 새로운 원본을 만드는 마술(CRDT) - 1. Operation의 디자인 방법</h1><div class="max-w-3xl mx-auto"><div class="mb-6 text-lg"><div>Written by <!-- -->Kim Dong Hun</div><time dateTime="2022-10-10">October	10, 2022</time></div></div><div class="max-w-3xl mx-auto"><div class="mb-6 text-lg"><div>Category:<!-- --> <span>#<!-- -->CRDT</span><span>#<!-- -->distributed-systems</span></div></div></div><div class="max-w-3xl mx-auto"><div class="markdown-styles_markdown__h_8de"><h2>CRDT에서 말하는 Operation의 디자인 원칙</h2>
<p>디지털 세계에서는 하나의 원본이 존재하되, 실제 사용은 여러 개의 복사본으로 사용되는 경우가 대다수다. 여러분이 보고 있는 이 블로그 웹사이트 또한 사실 원본에서 파생한 복사본이라고 볼 수 있다. 인터넷 연결이 갑자기 중단된다고 해도 여러분은 이 블로그 웹사이트가 아직 인터넷이 연결된 것처럼 사용할 수 있을 것이기 때문이다. 하지만 어떤 서비스 같은 경우 단순히 보는 것에 그치지 않고 사용자가 직접 행위를 할 수 있게끔 기능을 제공하기도 한다. 가장 대표적인 예시로 동시문서편집기가 있다. 동시문서편집기를 사용할 때 사용자는 자유롭게 글자를 넣거나 빼고 글자에 스타일을 넣기도 한다. 하지만 방금 언급한 블로그 웹사이트 사례처럼, 사실 사용자가 자기 컴퓨터에서 행하는 모든 행위는 원본에서 파생된 복사본에서 이루어지는 행위(operation)이다. 사용자 한 명만 operation을 행했다면 걱정거리가 없다. 복사본에서 행해진 operation을 그대로 원본에다 적용하면 된다. 하지만 동시문서편집기는 그런 의도로 사용되지 않는다. 동시문서편집기는 다수의 사용자가 동시에 작업을 하기 위한 서비스이다. 모두가 각자의 복사본에서 operation을 가한다. 이 모든 operation들을 통일해서 동일한 새로운 원본을 각 사용자에게 다시 복사본으로 제공해야 하는데 이것은 어떻게 해결할까? 그것을 해결하기 위한 하나의 방법인 CRDT에 대해서 글을 쓰고자 한다.</p>
<h4>여담..</h4>
<p>CRDT는 네이버에서 <a href="https://yorkie.dev/">Yorkie</a>를 작업하면서 알게 된 개념이다. 1달동안 인턴을 해도 제대로 이해하지 못했던 개념이라, 언젠가 한번 꼭 제대로 이해해야겠다는 생각을 했었다. 그러던 어느 날 최근에 <a href="https://github.com/yorkie-team/yorkie-js-sdk">yorkie-js-sdk</a>을 개선할 일이 생겼는데, CRDT를 이해하지 못한 이상 개선하기가 어렵다는 것을 깨닫고 미루고 미루었던 CRDT 공부를 하기 시작했다. 사실 CRDT를 제대로 공부하고 싶었던 이유는 이후 한번 만들어보고 싶은 <code>게임 서버</code>를 제작할 때 도움이 될 것 같았기 때문이다. 그동안 프론트엔드 세계에서만 지낸 것 같아서 다른 컴퓨터 세상을 맛보고 싶었다. 그런 갈증을 느끼던 와중 학교에서 컴퓨터 구조 수업을 들으면서 concurrency 개념을 맛보고 그런 쪽으로 지식을 좀 더 쌓고 싶은 생각이 들었다. 여름방학이 되자 네이버에서 인턴을 하게 되었는데 마침 concurrency와 관련된 동시문서편집기를 위한 라이브러리에 기여하는 일을 하게 되었다. CRDT는 이때 처음 맞닥뜨렸고, 이 내용을 좀 더 제대로 이해하면 클라우드나 서버 제작에서 사용할 수 있는 유용한 지식이라는 생각이 들었다 (무언가 만들면서 배우는 것을 좋아하는 사람이다보니..). 나중에 CRDT를 제대로 이해하고 나서 게임 서버를 만드는 여정에 대해서도 써볼까 한다.</p>
<h4>state &#x3C;= Operation(state) : Operations should be monotonic updates!</h4>
<p><code>CRDT에는 원본 update를 위한 두가지 방법인 operation-based replication과 state-based replication이 있다. 이 글은 state-based replication에 바탕하여 CRDT를 설명한다</code></p>
<p>복사본에서 이루어지는 행위들은 겹칠 수 있기 때문에 문제시된다. 밑에 예시를 한번 보자</p>
<ol>
<li>A와 B가 {1,2}라는 집합을 갖고 시작한다.</li>
<li>A와 B의 인터넷 연결이 끊긴다</li>
<li>A는 집합에다 3을 추가하고 나서 바로 3을 삭제한다.</li>
<li>B는 집합에다 3을 추가한다</li>
<li>인터넷이 다시 연결된다</li>
<li>결과는?</li>
</ol>
<p>여기서 인터넷 연결이 끊기는 상황을 연출한 이유는 원본에서 파생된 복사본이라는 사실을 명확히하기 위해서이다. 인터넷 연결이 끊긴 시점부터 A와 B는 각자 복사본에다 operation을 가하고 있는 것이다. 인터넷이 다시 연결되면 각 복사본에서 행해진 operation은 취합되어 새로운 원본(=집합)을 서로에게 줘야 한다. 맥락만 보면 {1,2,3}이 정답이 되어야 할 것 같다. 그러나 이것을 어떻게 컴퓨터가 이해하도록 operation을 디자인할까?</p>
<p>CRDT에서 state-based replcation에 기반한 operation은 monotonic update만 허락된다 <sup><a href="#footnote_1">1</a></sup>.</p>
<p>Reference)
<a name="footnote_1">1</a> Conflict-free Replicated Data Types
CRDT vs OT: https://channel.io/ko/blog/crdt_vs_ot</p>
</div></div><section></section></article></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"하나의 원본에서 파생된 여러 복사본에 가해지는 operation을 취합하여 통일된 새로운 원본을 만드는 마술(CRDT) - 1. Operation의 디자인 방법","date":"2022-10-10","slug":"crdt_operations","author":{"name":"Kim Dong Hun"},"content":"\u003ch2\u003eCRDT에서 말하는 Operation의 디자인 원칙\u003c/h2\u003e\n\u003cp\u003e디지털 세계에서는 하나의 원본이 존재하되, 실제 사용은 여러 개의 복사본으로 사용되는 경우가 대다수다. 여러분이 보고 있는 이 블로그 웹사이트 또한 사실 원본에서 파생한 복사본이라고 볼 수 있다. 인터넷 연결이 갑자기 중단된다고 해도 여러분은 이 블로그 웹사이트가 아직 인터넷이 연결된 것처럼 사용할 수 있을 것이기 때문이다. 하지만 어떤 서비스 같은 경우 단순히 보는 것에 그치지 않고 사용자가 직접 행위를 할 수 있게끔 기능을 제공하기도 한다. 가장 대표적인 예시로 동시문서편집기가 있다. 동시문서편집기를 사용할 때 사용자는 자유롭게 글자를 넣거나 빼고 글자에 스타일을 넣기도 한다. 하지만 방금 언급한 블로그 웹사이트 사례처럼, 사실 사용자가 자기 컴퓨터에서 행하는 모든 행위는 원본에서 파생된 복사본에서 이루어지는 행위(operation)이다. 사용자 한 명만 operation을 행했다면 걱정거리가 없다. 복사본에서 행해진 operation을 그대로 원본에다 적용하면 된다. 하지만 동시문서편집기는 그런 의도로 사용되지 않는다. 동시문서편집기는 다수의 사용자가 동시에 작업을 하기 위한 서비스이다. 모두가 각자의 복사본에서 operation을 가한다. 이 모든 operation들을 통일해서 동일한 새로운 원본을 각 사용자에게 다시 복사본으로 제공해야 하는데 이것은 어떻게 해결할까? 그것을 해결하기 위한 하나의 방법인 CRDT에 대해서 글을 쓰고자 한다.\u003c/p\u003e\n\u003ch4\u003e여담..\u003c/h4\u003e\n\u003cp\u003eCRDT는 네이버에서 \u003ca href=\"https://yorkie.dev/\"\u003eYorkie\u003c/a\u003e를 작업하면서 알게 된 개념이다. 1달동안 인턴을 해도 제대로 이해하지 못했던 개념이라, 언젠가 한번 꼭 제대로 이해해야겠다는 생각을 했었다. 그러던 어느 날 최근에 \u003ca href=\"https://github.com/yorkie-team/yorkie-js-sdk\"\u003eyorkie-js-sdk\u003c/a\u003e을 개선할 일이 생겼는데, CRDT를 이해하지 못한 이상 개선하기가 어렵다는 것을 깨닫고 미루고 미루었던 CRDT 공부를 하기 시작했다. 사실 CRDT를 제대로 공부하고 싶었던 이유는 이후 한번 만들어보고 싶은 \u003ccode\u003e게임 서버\u003c/code\u003e를 제작할 때 도움이 될 것 같았기 때문이다. 그동안 프론트엔드 세계에서만 지낸 것 같아서 다른 컴퓨터 세상을 맛보고 싶었다. 그런 갈증을 느끼던 와중 학교에서 컴퓨터 구조 수업을 들으면서 concurrency 개념을 맛보고 그런 쪽으로 지식을 좀 더 쌓고 싶은 생각이 들었다. 여름방학이 되자 네이버에서 인턴을 하게 되었는데 마침 concurrency와 관련된 동시문서편집기를 위한 라이브러리에 기여하는 일을 하게 되었다. CRDT는 이때 처음 맞닥뜨렸고, 이 내용을 좀 더 제대로 이해하면 클라우드나 서버 제작에서 사용할 수 있는 유용한 지식이라는 생각이 들었다 (무언가 만들면서 배우는 것을 좋아하는 사람이다보니..). 나중에 CRDT를 제대로 이해하고 나서 게임 서버를 만드는 여정에 대해서도 써볼까 한다.\u003c/p\u003e\n\u003ch4\u003estate \u0026#x3C;= Operation(state) : Operations should be monotonic updates!\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eCRDT에는 원본 update를 위한 두가지 방법인 operation-based replication과 state-based replication이 있다. 이 글은 state-based replication에 바탕하여 CRDT를 설명한다\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e복사본에서 이루어지는 행위들은 겹칠 수 있기 때문에 문제시된다. 밑에 예시를 한번 보자\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA와 B가 {1,2}라는 집합을 갖고 시작한다.\u003c/li\u003e\n\u003cli\u003eA와 B의 인터넷 연결이 끊긴다\u003c/li\u003e\n\u003cli\u003eA는 집합에다 3을 추가하고 나서 바로 3을 삭제한다.\u003c/li\u003e\n\u003cli\u003eB는 집합에다 3을 추가한다\u003c/li\u003e\n\u003cli\u003e인터넷이 다시 연결된다\u003c/li\u003e\n\u003cli\u003e결과는?\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e여기서 인터넷 연결이 끊기는 상황을 연출한 이유는 원본에서 파생된 복사본이라는 사실을 명확히하기 위해서이다. 인터넷 연결이 끊긴 시점부터 A와 B는 각자 복사본에다 operation을 가하고 있는 것이다. 인터넷이 다시 연결되면 각 복사본에서 행해진 operation은 취합되어 새로운 원본(=집합)을 서로에게 줘야 한다. 맥락만 보면 {1,2,3}이 정답이 되어야 할 것 같다. 그러나 이것을 어떻게 컴퓨터가 이해하도록 operation을 디자인할까?\u003c/p\u003e\n\u003cp\u003eCRDT에서 state-based replcation에 기반한 operation은 monotonic update만 허락된다 \u003csup\u003e\u003ca href=\"#footnote_1\"\u003e1\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003eReference)\n\u003ca name=\"footnote_1\"\u003e1\u003c/a\u003e Conflict-free Replicated Data Types\nCRDT vs OT: https://channel.io/ko/blog/crdt_vs_ot\u003c/p\u003e\n","keyword":"CRDT Basics","categories":["CRDT","distributed-systems"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"crdt_operations"},"buildId":"QbQQ_OOkCyxZZcdQD6e3a","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>